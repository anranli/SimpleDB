Jhoong Roh, cs186-eh
Anran Li, cs186-mz

1. Design decisions
Lock granularity: Page-level. The buffer pool holds pages so it's easier to simply work with pages when locking.
Deadlock detection: Created a separate LockManager class that handles locking and unlocking of pages. LockManager has internal data structures that keeps track of which pages are locked by which transactions with what permissions. LockManager's lock() method locks a page. It checks the status of the page and handles all the logic behind handling a certain case (which transaction locks, previous locks on the page, permission of previous/new lock). Deadlock detection runs by checking when 1 or more pages locks or wants to lock a page with READ_WRITE access. In the current implementation, deadlock is detected by waiting and then aborting on certain conditions involving locking pages with READ_WRITE permissions. The logic for detection is mostly in lock() and resolution is in block().
Deadlock resolution: Aborts yourself. First, you would wait for a certain amount of time for the lock to be free. After a certain amount of time, you'd know there's a deadlock and abort yourself so the other transaction can run.

2. NO STEAL/FORCE and STEAL/NO FORCE
NO STEAL - shouldn't evict dirty pages from buffer pool if locked by uncommitted transaction
FORCE - write all dirty pages to disk on transaction commit
NO STEAL makes life easier because you don't have to worry about pages on disk possibly being updated before transactionComplete. If the transaction aborts or system crashes during any part of the transaction, you can simply discard the page changes made in memory or memory will be lost. You can simply redo the entire transaction on crash. You don't have to worry about undoing certain page writes because the persisting writes to disk was never made. This makes it easier to manage atomicity because in conjunction with FORCE, either all of the writes of the transaction happen or none of it happen.
FORCE makes life easier because you always write all dirty pages to disk on commit. In conjunction with NO STEAL, it makes it easier to maintain atomicity because either all the pages modified by the transaction are written to disk (the transaction happened) or none of them are written. Also, it ensures durability because the (abort/crash) effects of the transaction persists after the transaction. Writing to disk after every transaction can be slower than let's say if on the next several transactions, you access the same pages, and then writing the effects of all of them at the end. However FORCE makes it easier for us to not have to calculate and worry about when we should write. Also, if abort/crashes happened during a transaction, we still maintain atomicity and durability. All of the writes from previous transactions persist (durability). None of the aborted/crashed transaction happened (atomicity). The most we'd have to worry about is redoing the most recent transaction.
The fact that we do not have to worry about the system crashing while running transactionComplete means that we can use NO STEAL/FORCE without worrying about the consequences of it crashing during commit. If it were to crash during transactionComplete, not all of the writes during FORCE will be completed. If only part of the writes during FORCE is completed and the system crashes, some pages are now the updated pages resulting from after the transaction while others are from before. Atomicity would no longer hold because parts of the writes from the transaction happened instead of all or none. Also, durability no longer holds because the transaction committed but not all of the changes made by the transaction persists. So, the complicated part of implementing NO STEAL/FORCE would be resolving these above issues if the system crashes during transactionComplete/commit. It would be hard to figure out which pages are old and which ones are done by the transaction that crashed during commit. We would then have to figure out which parts of the transaction needs to be undone or redone. At minimum, we need a system to help remember which pages have been written and which have not. One solution is to use  loggin. More information about how a log can help resolve this issue is below.
STEAL - able to write dirty pages to disk during the transaction
NO FORCE - doesn't guarantee that all dirty pages are written to disk on commit.
STEAL/NO FORCE is harder to implement than NO STEAL/FORCE because STEAL can be writing dirty pages to disk as the transaction is happening. If there was an abort or if the system crashed during the transaction, some of the transaction effects persist because they were written to disk while others do not. NO FORCE means that not all the dirty pages are written to disk on transaction complete. That means none or some of the writes done by a transaction can be written before transactionComplete. None or some can also happen after. So, if there is a crash, none, all, or multiple writes done by a transaction can be lost. Atomicity is not maintained if there is an abort or crash and you do not figure out which writes to undo or redo. As we stated above, it is hard to figure out which pages are the new pages and which are the old pages and which writes were done by which transaction in what order. To implement STEAL/NO FORCE, we would need to implement logging, which also helps fix crashing on NO STEAL/FORCE transaction commit as mentioned above. Logging helps us keep track of what parts of the transactions have writes that were executed and what has not and in what order. One type of log we can use is Write-Ahead Logging. We force the log record to update before updating a page on disk and force all the records for the transaction to be written before commit. It is important to log information that will allow us to REDO and UNDO transactions and writes. Some ways might be logging what pages were written to disk and what was not, which pages are changed by which transactions, and what order transactions happened. So, if a system crash happened during the middle of commit, we know which values have been written to disk and which haven't. Logging allows UNDO transactions that were aborted/crashed which helps guarantees atomicity and REDO transactions that committed but crashed before written which helps guarantee durability.

3. ACID properties
Atomicity - all actions or none happen. NO STEAL and FORCE ensures that the entire transaction happens or none happen at all because the dirty pages are written only to disk on the commit of the transaction. So, if system crashes happened during transaction, none of the pages would have been written to disk so none of the transaction happened. If there is no crash, all of the transaction happened.
Consistency - the database starts consistent and ends consistent. FORCE/NO STEAL doesn't really affect this property.
Isolation - execution of one transaction if isolated from others. FORCE/NO STEAL doesn't really affect this property.
Durability - if commits, then effects persist. FORCE ensures that the effects of a transaction persists because you write all dirty pages out to disk when committing a transaction. When the pages are written to disk, the effects of the transaction persist.
Refer to part 2 for more details.

4. Changes to API
Added a LockManager class that handles locking. LockManager has several internal ConcurrentHashMaps that keep track of which transactions hold locks on which pages with what permissions. It also has lock() and removeLock() methods that locks and unlocks pages. Other methods like getPageLock(), holdsLock(), and getPages() check for whether something is being locked and returns info relating to the lock.
