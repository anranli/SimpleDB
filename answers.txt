1. Design decisions
Lock granularity: Page-level. The buffer pool holds pages so it's easier to simply work with pages when locking.
Deadlock detection: Created a separate LockManager class that handles locking and unlocking of pages. LockManager has internal data structures that keeps track of which pages are locked by which transactions with what permissions. LockManager's lock() method locks a page. It checks the status of the page and handles all the logic behind handling a certain case (which transaction locks, previous locks on the page, permission of previous/new lock). Deadlock detection runs by checking when 1 or more pages locks or wants to lock a page with READ_WRITE access. In the current implementation, deadlock is detected by waiting and then aborting on certain conditions involving locking pages with READ_WRITE permissions. The logic for detection is mostly in lock() and resolution is in block().
Deadlock resolution: Aborts yourself. First, you would wait for a certain amount of time for the lock to be free. After a certain amount of time, you'd know there's a deadlock and abort yourself so the other transaction can run.

2. NO STEAL/FORCE and STEAL/NO FORCE
NO STEAL makes life easier because you don't have to worry about pages on disk being updated before transactionComplete (commit). If the transaction aborts or system crashes during the transaction, you can undo the transaction by discarding the page changes made in memory or because memory will be lost. You don't worry about undoing certain page writes because the persisting writes to disk were never made. This makes it easier to manage atomicity because in conjunction with FORCE, either all of the writes of the transaction happen (no crashes) or none of it happen.
FORCE makes life easier because dirty pages are written to disk on commit. In conjunction with NO STEAL, it makes it easier to maintain atomicity because either all the pages modified by the transaction are written to disk (the transaction happened) or none of them are written. Also, it ensures durability because the effects of the transaction persists after the transaction even if there are aborts or crashes in following transactions. If abort/crashes happened during a transaction, we still maintain atomicity and durability. All of the writes from previous transactions persist (durability). None of the aborted/crashed transaction happened (atomicity). The most we'd have to worry about is redoing the most recent transaction.
The fact that we do not have to worry about the system crashing while running transactionComplete means that it makes NO STEAL/FORCE easier to implement. If it were to crash during transactionComplete, not all of the writes during FORCE will be completed. Then, some pages are now the updated pages resulting from after the transaction while others are from before. Atomicity would no longer hold because parts of the writes from the transaction happened instead of all or none. Also, durability no longer holds because the transaction committed but not all of the changes made by the transaction persists. So, the complicated part of implementing NO STEAL/FORCE would be resolving these above issues if the system crashes during transactionComplete/commit. It would be hard to figure out which pages are old/done by the transaction that crashed during commit. We would then have to figure out which parts of the transaction needs to be undone or redone. At minimum, we need a system to help remember which pages have been written and which have not. One solution is to use  logging. More information about how a log can help resolve this issue is below.

STEAL/NO FORCE is harder to implement than NO STEAL/FORCE because STEAL can write dirty pages to disk as the transaction is happening. If there was an abort or if the system crashed during the transaction, some of the transaction effects persist because they were written to disk while others do not. NO FORCE means that not all the dirty pages are written to disk on transaction complete. So, if there is a crash, depending on how much was written as a result of STEAL, none, all, or multiple writes done by a transaction can be lost. Atomicity is not maintained if there is an abort or crash and you do not figure out which writes to undo or redo. As we stated above, it is hard to figure out which pages are the new pages and which are the old pages and which writes were done by which transaction in what order. To implement STEAL/NO FORCE, we would need to implement logging, which also helps fix crashing on NO STEAL/FORCE transaction commit as mentioned above. One type of log we can use is Write-Ahead Logging. We force the log record to update before updating a page on disk and force all the records for the transaction to be written before commit. It is important to log information that will allow us to REDO and UNDO transactions and writes. Some ways might be logging what pages were written to disk, which pages are changed by which transactions, and what order transactions happened. So, if a system crash happened during the middle of commit, we know which values have been written to disk and which haven't. Logging allows UNDO transactions that were aborted/crashed which helps guarantees atomicity and REDO transactions that committed but crashed before written which helps guarantee durability.

3. ACID properties
Atomicity - all actions or none happen. NO STEAL and FORCE with no crash during transaction complete ensures that the entire transaction happens or none happen at all because the dirty pages are written only to disk on the commit of the transaction. So, if system crashes/transaction aborts happened during transaction, none of the pages would have been written to disk so none of the transaction happened. If there is no crash/abort, all of the transaction happened.
Consistency - FORCE/NO STEAL doesn't really affect this property.
Isolation - FORCE/NO STEAL doesn't really affect this property.
Durability - if commits, then effects persist. FORCE ensures that the effects of a transaction persists because you write all dirty pages out to disk when committing a transaction. When the pages are written to disk, the effects of the transaction persist. Since transactionComplete never crashes, all dirty pages get flushed.
A lot of this is explained in part 2.

4. Changes to API
Added a LockManager class that handles locking. LockManager has several internal ConcurrentHashMaps that keep track of which transactions hold locks on which pages with what permissions. It also has lock() and removeLock() methods that locks and unlocks pages. Other methods like getPageLock(), holdsLock(), and getPages() check for whether something is being locked and returns info relating to the lock.